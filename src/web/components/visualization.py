"""
Streamlined visualization component for the AI Copilot web interface.
Focuses exclusively on displaying Plotly charts generated by the visualizer agent.
"""
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import logging
import json
from typing import Dict, Any, List, Optional
import time

logger = logging.getLogger("gabi.web.visualization")

def render_visualization(config: Dict[str, Any], data: Optional[List[Dict[str, Any]]] = None) -> bool:
    """
    Main visualization rendering function.
    Handles Plotly figures and fallback cases.
    """
    logger.info(f"=== RENDER_VISUALIZATION CALLED ===")
    logger.info(f"Config chart_type: {config.get('chart_type') if config else 'None'}")
    logger.info(f"Config has figure_json: {bool(config.get('figure_json')) if config else False}")
    
    if not config:
        st.info("No visualization configuration available")
        logger.warning("No config provided to render_visualization")
        return False
    
    try:
        chart_type = config.get("chart_type", "none")
        
        # Handle Plotly figures from the visualizer agent
        if chart_type == "plotly" and config.get("figure_json"):
            logger.info("✅ Rendering Plotly figure from visualizer agent")
            return render_plotly_figure(config)
        
        # Handle code display for SQL queries that couldn't be executed
        elif chart_type == "code_display":
            return render_code_display(config)
        
        # Handle case where no visualization is available
        elif chart_type == "none":
            message = config.get("message", "No visualization data available")
            st.info(f"ℹ️ {message}")
            return False
        
        # Fallback for any other chart types
        else:
            logger.warning(f"Unknown chart type: {chart_type}")
            st.warning(f"Unsupported chart type: {chart_type}")
            return False
        
    except Exception as e:
        logger.error(f"Visualization error: {e}")
        st.error(f"Error displaying visualization: {e}")
        return False

def render_plotly_figure(config: Dict[str, Any]) -> bool:
    """
    Render a Plotly figure from the configuration.
    """
    try:
        figure_json = config.get("figure_json")
        title = config.get("title", "Visualization")
        description = config.get("description", "")
        
        if not figure_json:
            st.error("No figure data available")
            return False
        
        # Parse and display the Plotly figure
        logger.info("Parsing Plotly figure JSON")
        fig_dict = json.loads(figure_json)
        fig = go.Figure(fig_dict)
        
        # Display the chart
        st.plotly_chart(fig, use_container_width=True, key=f"plotly_{int(time.time() * 1000)}")
        
        # Show chart description if available
        if description:
            st.caption(f"📊 {description}")
        
        # Add download button
        add_download_button(fig, title)
        
        # Show underlying data in an expander if available
        if config.get("data"):
            show_underlying_data(config["data"])
        
        logger.info("✅ Successfully rendered Plotly figure")
        return True
        
    except json.JSONDecodeError as e:
        logger.error(f"Error parsing figure JSON: {e}")
        st.error("Error parsing visualization data")
        return False
    except Exception as e:
        logger.error(f"Error rendering Plotly figure: {e}")
        st.error(f"Error displaying chart: {e}")
        return False

def render_code_display(config: Dict[str, Any]) -> bool:
    """
    Render code display for SQL queries that couldn't be executed.
    """
    try:
        message = config.get("message", "Code generated but not executed")
        sql_code = config.get("sql_code", "")
        
        st.warning(f"⚠️ {message}")
        
        if sql_code:
            st.subheader("Generated SQL Query")
            st.code(sql_code, language="sql")
            
            # Show helpful instructions
            if "connection details needed" in message.lower():
                st.info("💡 To execute this query, please connect to your database using the **Connect to Database** tab above.")
            elif "local database" in message.lower():
                st.info("💡 Query was attempted against local database. Check the database file and query syntax.")
            else:
                st.info("💡 To execute this query, please ensure your database connection is properly configured.")
        
        return True
        
    except Exception as e:
        logger.error(f"Error rendering code display: {e}")
        st.error(f"Error displaying code: {e}")
        return False

def add_download_button(fig: go.Figure, title: str) -> None:
    """
    Add a download button for the Plotly figure.
    """
    try:
        img_bytes = fig.to_image(format="png", scale=2)
        filename = f"{title.replace(' ', '_').replace(':', '_')}.png"
        
        st.download_button(
            label="💾 Download Chart",
            data=img_bytes,
            file_name=filename,
            mime="image/png",
            key=f"download_{int(time.time() * 1000)}"
        )
    except Exception as e:
        logger.warning(f"Could not generate download image: {e}")
        st.caption("⚠️ Chart download requires the 'kaleido' package")

def show_underlying_data(data: List[Dict[str, Any]]) -> None:
    """
    Show the underlying data in an expander.
    """
    try:
        with st.expander("📋 View Underlying Data", expanded=False):
            df = pd.DataFrame(data)
            st.dataframe(df, use_container_width=True)
            
            # Add data download
            csv_data = df.to_csv(index=False)
            st.download_button(
                label="💾 Download Data (CSV)",
                data=csv_data,
                file_name="chart_data.csv",
                mime="text/csv",
                key=f"data_download_{int(time.time() * 1000)}"
            )
            
    except Exception as e:
        logger.warning(f"Could not display underlying data: {e}")
        with st.expander("📋 View Underlying Data", expanded=False):
            st.json(data[:10] if len(data) > 10 else data)

# Legacy functions for backward compatibility
def auto_visualize_dataframe(df: pd.DataFrame, title: str = "Data Analysis") -> bool:
    """
    Legacy function for backward compatibility.
    Creates a simple table display.
    """
    try:
        if df.empty:
            st.info("DataFrame is empty")
            return False
        
        st.subheader(title)
        st.dataframe(df, use_container_width=True)
        return True
    
    except Exception as e:
        logger.error(f"Error in auto_visualize_dataframe: {e}")
        st.error(f"Error displaying data: {e}")
        return False

def display_data_table(data: List[Dict[str, Any]], title: str = "Data Table") -> bool:
    """
    Legacy function for backward compatibility.
    Displays data as a simple table.
    """
    try:
        if not data:
            st.info("No data to display")
            return False
        
        df = pd.DataFrame(data)
        st.subheader(title)
        st.dataframe(df, use_container_width=True)
        return True
    
    except Exception as e:
        logger.error(f"Error displaying data table: {e}")
        st.error(f"Error displaying table: {e}")
        return False
